// Code generated by Microsoft (R) AutoRest Code Generator 0.9.7.0
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Rest;
using Newtonsoft.Json.Linq;
using Oanda.Rest;
using Oanda.Rest.Models;

namespace Oanda.Rest.Models
{
    public partial class AccountModel
    {
        private string _accountCurrency;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string AccountCurrency
        {
            get { return this._accountCurrency; }
            set { this._accountCurrency = value; }
        }
        
        private int? _accountId;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public int? AccountId
        {
            get { return this._accountId; }
            set { this._accountId = value; }
        }
        
        private string _accountName;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string AccountName
        {
            get { return this._accountName; }
            set { this._accountName = value; }
        }
        
        private double? _balance;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Balance
        {
            get { return this._balance; }
            set { this._balance = value; }
        }
        
        private double? _marginAvail;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginAvail
        {
            get { return this._marginAvail; }
            set { this._marginAvail = value; }
        }
        
        private double? _marginRate;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginRate
        {
            get { return this._marginRate; }
            set { this._marginRate = value; }
        }
        
        private double? _marginUsed;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginUsed
        {
            get { return this._marginUsed; }
            set { this._marginUsed = value; }
        }
        
        private double? _openOrders;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenOrders
        {
            get { return this._openOrders; }
            set { this._openOrders = value; }
        }
        
        private double? _openTrades;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenTrades
        {
            get { return this._openTrades; }
            set { this._openTrades = value; }
        }
        
        private string _password;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Password
        {
            get { return this._password; }
            set { this._password = value; }
        }
        
        private double? _realizedPl;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? RealizedPl
        {
            get { return this._realizedPl; }
            set { this._realizedPl = value; }
        }
        
        private double? _unrealizedPl;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? UnrealizedPl
        {
            get { return this._unrealizedPl; }
            set { this._unrealizedPl = value; }
        }
        
        private string _username;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Username
        {
            get { return this._username; }
            set { this._username = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the AccountModel class.
        /// </summary>
        public AccountModel()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken accountCurrencyValue = inputObject["accountCurrency"];
                if (accountCurrencyValue != null && accountCurrencyValue.Type != JTokenType.Null)
                {
                    this.AccountCurrency = ((string)accountCurrencyValue);
                }
                JToken accountIdValue = inputObject["accountId"];
                if (accountIdValue != null && accountIdValue.Type != JTokenType.Null)
                {
                    this.AccountId = ((int)accountIdValue);
                }
                JToken accountNameValue = inputObject["accountName"];
                if (accountNameValue != null && accountNameValue.Type != JTokenType.Null)
                {
                    this.AccountName = ((string)accountNameValue);
                }
                JToken balanceValue = inputObject["balance"];
                if (balanceValue != null && balanceValue.Type != JTokenType.Null)
                {
                    this.Balance = ((double)balanceValue);
                }
                JToken marginAvailValue = inputObject["marginAvail"];
                if (marginAvailValue != null && marginAvailValue.Type != JTokenType.Null)
                {
                    this.MarginAvail = ((double)marginAvailValue);
                }
                JToken marginRateValue = inputObject["marginRate"];
                if (marginRateValue != null && marginRateValue.Type != JTokenType.Null)
                {
                    this.MarginRate = ((double)marginRateValue);
                }
                JToken marginUsedValue = inputObject["marginUsed"];
                if (marginUsedValue != null && marginUsedValue.Type != JTokenType.Null)
                {
                    this.MarginUsed = ((double)marginUsedValue);
                }
                JToken openOrdersValue = inputObject["openOrders"];
                if (openOrdersValue != null && openOrdersValue.Type != JTokenType.Null)
                {
                    this.OpenOrders = ((double)openOrdersValue);
                }
                JToken openTradesValue = inputObject["openTrades"];
                if (openTradesValue != null && openTradesValue.Type != JTokenType.Null)
                {
                    this.OpenTrades = ((double)openTradesValue);
                }
                JToken passwordValue = inputObject["password"];
                if (passwordValue != null && passwordValue.Type != JTokenType.Null)
                {
                    this.Password = ((string)passwordValue);
                }
                JToken realizedPlValue = inputObject["realizedPl"];
                if (realizedPlValue != null && realizedPlValue.Type != JTokenType.Null)
                {
                    this.RealizedPl = ((double)realizedPlValue);
                }
                JToken unrealizedPlValue = inputObject["unrealizedPl"];
                if (unrealizedPlValue != null && unrealizedPlValue.Type != JTokenType.Null)
                {
                    this.UnrealizedPl = ((double)unrealizedPlValue);
                }
                JToken usernameValue = inputObject["username"];
                if (usernameValue != null && usernameValue.Type != JTokenType.Null)
                {
                    this.Username = ((string)usernameValue);
                }
            }
        }
    }
    
    public partial class CandleModel
    {
        private double? _closeAsk;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? CloseAsk
        {
            get { return this._closeAsk; }
            set { this._closeAsk = value; }
        }
        
        private double? _closeBid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? CloseBid
        {
            get { return this._closeBid; }
            set { this._closeBid = value; }
        }
        
        private bool? _complete;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public bool? Complete
        {
            get { return this._complete; }
            set { this._complete = value; }
        }
        
        private double? _highAsk;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? HighAsk
        {
            get { return this._highAsk; }
            set { this._highAsk = value; }
        }
        
        private double? _highBid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? HighBid
        {
            get { return this._highBid; }
            set { this._highBid = value; }
        }
        
        private double? _highMid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? HighMid
        {
            get { return this._highMid; }
            set { this._highMid = value; }
        }
        
        private double? _lowAsk;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? LowAsk
        {
            get { return this._lowAsk; }
            set { this._lowAsk = value; }
        }
        
        private double? _lowBid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? LowBid
        {
            get { return this._lowBid; }
            set { this._lowBid = value; }
        }
        
        private double? _lowMid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? LowMid
        {
            get { return this._lowMid; }
            set { this._lowMid = value; }
        }
        
        private double? _openAsk;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenAsk
        {
            get { return this._openAsk; }
            set { this._openAsk = value; }
        }
        
        private double? _openBid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenBid
        {
            get { return this._openBid; }
            set { this._openBid = value; }
        }
        
        private double? _openMid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenMid
        {
            get { return this._openMid; }
            set { this._openMid = value; }
        }
        
        private DateTimeOffset? _time;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public DateTimeOffset? Time
        {
            get { return this._time; }
            set { this._time = value; }
        }
        
        private long? _volume;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public long? Volume
        {
            get { return this._volume; }
            set { this._volume = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the CandleModel class.
        /// </summary>
        public CandleModel()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken closeAskValue = inputObject["closeAsk"];
                if (closeAskValue != null && closeAskValue.Type != JTokenType.Null)
                {
                    this.CloseAsk = ((double)closeAskValue);
                }
                JToken closeBidValue = inputObject["closeBid"];
                if (closeBidValue != null && closeBidValue.Type != JTokenType.Null)
                {
                    this.CloseBid = ((double)closeBidValue);
                }
                JToken completeValue = inputObject["complete"];
                if (completeValue != null && completeValue.Type != JTokenType.Null)
                {
                    this.Complete = ((bool)completeValue);
                }
                JToken highAskValue = inputObject["highAsk"];
                if (highAskValue != null && highAskValue.Type != JTokenType.Null)
                {
                    this.HighAsk = ((double)highAskValue);
                }
                JToken highBidValue = inputObject["highBid"];
                if (highBidValue != null && highBidValue.Type != JTokenType.Null)
                {
                    this.HighBid = ((double)highBidValue);
                }
                JToken highMidValue = inputObject["highMid"];
                if (highMidValue != null && highMidValue.Type != JTokenType.Null)
                {
                    this.HighMid = ((double)highMidValue);
                }
                JToken lowAskValue = inputObject["lowAsk"];
                if (lowAskValue != null && lowAskValue.Type != JTokenType.Null)
                {
                    this.LowAsk = ((double)lowAskValue);
                }
                JToken lowBidValue = inputObject["lowBid"];
                if (lowBidValue != null && lowBidValue.Type != JTokenType.Null)
                {
                    this.LowBid = ((double)lowBidValue);
                }
                JToken lowMidValue = inputObject["lowMid"];
                if (lowMidValue != null && lowMidValue.Type != JTokenType.Null)
                {
                    this.LowMid = ((double)lowMidValue);
                }
                JToken openAskValue = inputObject["openAsk"];
                if (openAskValue != null && openAskValue.Type != JTokenType.Null)
                {
                    this.OpenAsk = ((double)openAskValue);
                }
                JToken openBidValue = inputObject["openBid"];
                if (openBidValue != null && openBidValue.Type != JTokenType.Null)
                {
                    this.OpenBid = ((double)openBidValue);
                }
                JToken openMidValue = inputObject["openMid"];
                if (openMidValue != null && openMidValue.Type != JTokenType.Null)
                {
                    this.OpenMid = ((double)openMidValue);
                }
                JToken timeValue = inputObject["time"];
                if (timeValue != null && timeValue.Type != JTokenType.Null)
                {
                    this.Time = ((DateTimeOffset)timeValue);
                }
                JToken volumeValue = inputObject["volume"];
                if (volumeValue != null && volumeValue.Type != JTokenType.Null)
                {
                    this.Volume = ((long)volumeValue);
                }
            }
        }
    }
    
    public partial class CreateAccountOKResponse
    {
        private string _accountId;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string AccountId
        {
            get { return this._accountId; }
            set { this._accountId = value; }
        }
        
        private string _password;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Password
        {
            get { return this._password; }
            set { this._password = value; }
        }
        
        private string _username;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Username
        {
            get { return this._username; }
            set { this._username = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the CreateAccountOKResponse class.
        /// </summary>
        public CreateAccountOKResponse()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken accountIdValue = inputObject["accountId"];
                if (accountIdValue != null && accountIdValue.Type != JTokenType.Null)
                {
                    this.AccountId = ((string)accountIdValue);
                }
                JToken passwordValue = inputObject["password"];
                if (passwordValue != null && passwordValue.Type != JTokenType.Null)
                {
                    this.Password = ((string)passwordValue);
                }
                JToken usernameValue = inputObject["username"];
                if (usernameValue != null && usernameValue.Type != JTokenType.Null)
                {
                    this.Username = ((string)usernameValue);
                }
            }
        }
    }
    
    public partial class ErrorModel
    {
        private int? _code;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public int? Code
        {
            get { return this._code; }
            set { this._code = value; }
        }
        
        private string _message;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Message
        {
            get { return this._message; }
            set { this._message = value; }
        }
        
        private string _moreInfo;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string MoreInfo
        {
            get { return this._moreInfo; }
            set { this._moreInfo = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ErrorModel class.
        /// </summary>
        public ErrorModel()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken codeValue = inputObject["code"];
                if (codeValue != null && codeValue.Type != JTokenType.Null)
                {
                    this.Code = ((int)codeValue);
                }
                JToken messageValue = inputObject["message"];
                if (messageValue != null && messageValue.Type != JTokenType.Null)
                {
                    this.Message = ((string)messageValue);
                }
                JToken moreInfoValue = inputObject["moreInfo"];
                if (moreInfoValue != null && moreInfoValue.Type != JTokenType.Null)
                {
                    this.MoreInfo = ((string)moreInfoValue);
                }
            }
        }
    }
    
    public partial class GetAccountOKResponse
    {
        private string _accountCurrency;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string AccountCurrency
        {
            get { return this._accountCurrency; }
            set { this._accountCurrency = value; }
        }
        
        private double? _accountId;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? AccountId
        {
            get { return this._accountId; }
            set { this._accountId = value; }
        }
        
        private string _accountName;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string AccountName
        {
            get { return this._accountName; }
            set { this._accountName = value; }
        }
        
        private double? _balance;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Balance
        {
            get { return this._balance; }
            set { this._balance = value; }
        }
        
        private double? _marginAvail;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginAvail
        {
            get { return this._marginAvail; }
            set { this._marginAvail = value; }
        }
        
        private double? _marginRate;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginRate
        {
            get { return this._marginRate; }
            set { this._marginRate = value; }
        }
        
        private double? _marginUsed;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginUsed
        {
            get { return this._marginUsed; }
            set { this._marginUsed = value; }
        }
        
        private double? _openOrders;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenOrders
        {
            get { return this._openOrders; }
            set { this._openOrders = value; }
        }
        
        private double? _openTrades;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? OpenTrades
        {
            get { return this._openTrades; }
            set { this._openTrades = value; }
        }
        
        private double? _realizedPl;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? RealizedPl
        {
            get { return this._realizedPl; }
            set { this._realizedPl = value; }
        }
        
        private double? _unrealizedPl;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? UnrealizedPl
        {
            get { return this._unrealizedPl; }
            set { this._unrealizedPl = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the GetAccountOKResponse class.
        /// </summary>
        public GetAccountOKResponse()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken accountCurrencyValue = inputObject["accountCurrency"];
                if (accountCurrencyValue != null && accountCurrencyValue.Type != JTokenType.Null)
                {
                    this.AccountCurrency = ((string)accountCurrencyValue);
                }
                JToken accountIdValue = inputObject["accountId"];
                if (accountIdValue != null && accountIdValue.Type != JTokenType.Null)
                {
                    this.AccountId = ((double)accountIdValue);
                }
                JToken accountNameValue = inputObject["accountName"];
                if (accountNameValue != null && accountNameValue.Type != JTokenType.Null)
                {
                    this.AccountName = ((string)accountNameValue);
                }
                JToken balanceValue = inputObject["balance"];
                if (balanceValue != null && balanceValue.Type != JTokenType.Null)
                {
                    this.Balance = ((double)balanceValue);
                }
                JToken marginAvailValue = inputObject["marginAvail"];
                if (marginAvailValue != null && marginAvailValue.Type != JTokenType.Null)
                {
                    this.MarginAvail = ((double)marginAvailValue);
                }
                JToken marginRateValue = inputObject["marginRate"];
                if (marginRateValue != null && marginRateValue.Type != JTokenType.Null)
                {
                    this.MarginRate = ((double)marginRateValue);
                }
                JToken marginUsedValue = inputObject["marginUsed"];
                if (marginUsedValue != null && marginUsedValue.Type != JTokenType.Null)
                {
                    this.MarginUsed = ((double)marginUsedValue);
                }
                JToken openOrdersValue = inputObject["openOrders"];
                if (openOrdersValue != null && openOrdersValue.Type != JTokenType.Null)
                {
                    this.OpenOrders = ((double)openOrdersValue);
                }
                JToken openTradesValue = inputObject["openTrades"];
                if (openTradesValue != null && openTradesValue.Type != JTokenType.Null)
                {
                    this.OpenTrades = ((double)openTradesValue);
                }
                JToken realizedPlValue = inputObject["realizedPl"];
                if (realizedPlValue != null && realizedPlValue.Type != JTokenType.Null)
                {
                    this.RealizedPl = ((double)realizedPlValue);
                }
                JToken unrealizedPlValue = inputObject["unrealizedPl"];
                if (unrealizedPlValue != null && unrealizedPlValue.Type != JTokenType.Null)
                {
                    this.UnrealizedPl = ((double)unrealizedPlValue);
                }
            }
        }
    }
    
    public partial class GetAccountsOKResponse : IEnumerable<AccountModel>
    {
        private IList<AccountModel> _accounts;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public IList<AccountModel> Accounts
        {
            get { return this._accounts; }
            set { this._accounts = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the GetAccountsOKResponse class.
        /// </summary>
        public GetAccountsOKResponse()
        {
            this.Accounts = new LazyList<AccountModel>();
        }
        
        /// <summary>
        /// Gets the sequence of accounts.
        /// </summary>
        public IEnumerator<AccountModel> GetEnumerator()
        {
            return this.Accounts.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of accounts.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken accountsSequence = ((JToken)inputObject["accounts"]);
                if (accountsSequence != null && accountsSequence.Type != JTokenType.Null)
                {
                    foreach (JToken accountsValue in ((JArray)accountsSequence))
                    {
                        AccountModel accountModel = new AccountModel();
                        accountModel.DeserializeJson(accountsValue);
                        this.Accounts.Add(accountModel);
                    }
                }
            }
        }
    }
    
    public partial class GetCandlesOKResponse : IEnumerable<CandleModel>
    {
        private IList<CandleModel> _candles;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public IList<CandleModel> Candles
        {
            get { return this._candles; }
            set { this._candles = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the GetCandlesOKResponse class.
        /// </summary>
        public GetCandlesOKResponse()
        {
            this.Candles = new LazyList<CandleModel>();
        }
        
        /// <summary>
        /// Gets the sequence of candles.
        /// </summary>
        public IEnumerator<CandleModel> GetEnumerator()
        {
            return this.Candles.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of candles.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken candlesSequence = ((JToken)inputObject["candles"]);
                if (candlesSequence != null && candlesSequence.Type != JTokenType.Null)
                {
                    foreach (JToken candlesValue in ((JArray)candlesSequence))
                    {
                        CandleModel candleModel = new CandleModel();
                        candleModel.DeserializeJson(candlesValue);
                        this.Candles.Add(candleModel);
                    }
                }
            }
        }
    }
    
    public partial class GetInstrumentsOKResponse : IEnumerable<InstrumentModel>
    {
        private IList<InstrumentModel> _instruments;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public IList<InstrumentModel> Instruments
        {
            get { return this._instruments; }
            set { this._instruments = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the GetInstrumentsOKResponse class.
        /// </summary>
        public GetInstrumentsOKResponse()
        {
            this.Instruments = new LazyList<InstrumentModel>();
        }
        
        /// <summary>
        /// Gets the sequence of instruments.
        /// </summary>
        public IEnumerator<InstrumentModel> GetEnumerator()
        {
            return this.Instruments.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of instruments.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken instrumentsSequence = ((JToken)inputObject["instruments"]);
                if (instrumentsSequence != null && instrumentsSequence.Type != JTokenType.Null)
                {
                    foreach (JToken instrumentsValue in ((JArray)instrumentsSequence))
                    {
                        InstrumentModel instrumentModel = new InstrumentModel();
                        instrumentModel.DeserializeJson(instrumentsValue);
                        this.Instruments.Add(instrumentModel);
                    }
                }
            }
        }
    }
    
    public partial class GetPricesOKResponse : IEnumerable<PriceModel>
    {
        private IList<PriceModel> _prices;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public IList<PriceModel> Prices
        {
            get { return this._prices; }
            set { this._prices = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the GetPricesOKResponse class.
        /// </summary>
        public GetPricesOKResponse()
        {
            this.Prices = new LazyList<PriceModel>();
        }
        
        /// <summary>
        /// Gets the sequence of prices.
        /// </summary>
        public IEnumerator<PriceModel> GetEnumerator()
        {
            return this.Prices.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of prices.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken pricesSequence = ((JToken)inputObject["prices"]);
                if (pricesSequence != null && pricesSequence.Type != JTokenType.Null)
                {
                    foreach (JToken pricesValue in ((JArray)pricesSequence))
                    {
                        PriceModel priceModel = new PriceModel();
                        priceModel.DeserializeJson(pricesValue);
                        this.Prices.Add(priceModel);
                    }
                }
            }
        }
    }
    
    public partial class InstrumentModel
    {
        private string _displayName;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string DisplayName
        {
            get { return this._displayName; }
            set { this._displayName = value; }
        }
        
        private bool? _halted;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public bool? Halted
        {
            get { return this._halted; }
            set { this._halted = value; }
        }
        
        private string _instrument;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Instrument
        {
            get { return this._instrument; }
            set { this._instrument = value; }
        }
        
        private double? _marginRate;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MarginRate
        {
            get { return this._marginRate; }
            set { this._marginRate = value; }
        }
        
        private double? _maxTradeUnits;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MaxTradeUnits
        {
            get { return this._maxTradeUnits; }
            set { this._maxTradeUnits = value; }
        }
        
        private double? _maxTrailingStop;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MaxTrailingStop
        {
            get { return this._maxTrailingStop; }
            set { this._maxTrailingStop = value; }
        }
        
        private double? _minTrailingStop;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? MinTrailingStop
        {
            get { return this._minTrailingStop; }
            set { this._minTrailingStop = value; }
        }
        
        private double? _pip;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Pip
        {
            get { return this._pip; }
            set { this._pip = value; }
        }
        
        private double? _precision;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Precision
        {
            get { return this._precision; }
            set { this._precision = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the InstrumentModel class.
        /// </summary>
        public InstrumentModel()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken displayNameValue = inputObject["displayName"];
                if (displayNameValue != null && displayNameValue.Type != JTokenType.Null)
                {
                    this.DisplayName = ((string)displayNameValue);
                }
                JToken haltedValue = inputObject["halted"];
                if (haltedValue != null && haltedValue.Type != JTokenType.Null)
                {
                    this.Halted = ((bool)haltedValue);
                }
                JToken instrumentValue = inputObject["instrument"];
                if (instrumentValue != null && instrumentValue.Type != JTokenType.Null)
                {
                    this.Instrument = ((string)instrumentValue);
                }
                JToken marginRateValue = inputObject["marginRate"];
                if (marginRateValue != null && marginRateValue.Type != JTokenType.Null)
                {
                    this.MarginRate = ((double)marginRateValue);
                }
                JToken maxTradeUnitsValue = inputObject["maxTradeUnits"];
                if (maxTradeUnitsValue != null && maxTradeUnitsValue.Type != JTokenType.Null)
                {
                    this.MaxTradeUnits = ((double)maxTradeUnitsValue);
                }
                JToken maxTrailingStopValue = inputObject["maxTrailingStop"];
                if (maxTrailingStopValue != null && maxTrailingStopValue.Type != JTokenType.Null)
                {
                    this.MaxTrailingStop = ((double)maxTrailingStopValue);
                }
                JToken minTrailingStopValue = inputObject["minTrailingStop"];
                if (minTrailingStopValue != null && minTrailingStopValue.Type != JTokenType.Null)
                {
                    this.MinTrailingStop = ((double)minTrailingStopValue);
                }
                JToken pipValue = inputObject["pip"];
                if (pipValue != null && pipValue.Type != JTokenType.Null)
                {
                    this.Pip = ((double)pipValue);
                }
                JToken precisionValue = inputObject["precision"];
                if (precisionValue != null && precisionValue.Type != JTokenType.Null)
                {
                    this.Precision = ((double)precisionValue);
                }
            }
        }
    }
    
    public partial class PositionModel
    {
        private double? _avgPrice;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? AvgPrice
        {
            get { return this._avgPrice; }
            set { this._avgPrice = value; }
        }
        
        private string _instrument;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Instrument
        {
            get { return this._instrument; }
            set { this._instrument = value; }
        }
        
        private string _side;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Side
        {
            get { return this._side; }
            set { this._side = value; }
        }
        
        private double? _units;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Units
        {
            get { return this._units; }
            set { this._units = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the PositionModel class.
        /// </summary>
        public PositionModel()
        {
        }
    }
    
    public partial class PriceModel
    {
        private double? _ask;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Ask
        {
            get { return this._ask; }
            set { this._ask = value; }
        }
        
        private double? _bid;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public double? Bid
        {
            get { return this._bid; }
            set { this._bid = value; }
        }
        
        private string _instrument;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Instrument
        {
            get { return this._instrument; }
            set { this._instrument = value; }
        }
        
        private string _status;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public string Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private DateTimeOffset? _time;
        
        /// <summary>
        /// Optional.
        /// </summary>
        public DateTimeOffset? Time
        {
            get { return this._time; }
            set { this._time = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the PriceModel class.
        /// </summary>
        public PriceModel()
        {
        }
        
        /// <summary>
        /// Deserialize the object
        /// </summary>
        public virtual void DeserializeJson(JToken inputObject)
        {
            if (inputObject != null && inputObject.Type != JTokenType.Null)
            {
                JToken askValue = inputObject["ask"];
                if (askValue != null && askValue.Type != JTokenType.Null)
                {
                    this.Ask = ((double)askValue);
                }
                JToken bidValue = inputObject["bid"];
                if (bidValue != null && bidValue.Type != JTokenType.Null)
                {
                    this.Bid = ((double)bidValue);
                }
                JToken instrumentValue = inputObject["instrument"];
                if (instrumentValue != null && instrumentValue.Type != JTokenType.Null)
                {
                    this.Instrument = ((string)instrumentValue);
                }
                JToken statusValue = inputObject["status"];
                if (statusValue != null && statusValue.Type != JTokenType.Null)
                {
                    this.Status = ((string)statusValue);
                }
                JToken timeValue = inputObject["time"];
                if (timeValue != null && timeValue.Type != JTokenType.Null)
                {
                    this.Time = ((DateTimeOffset)timeValue);
                }
            }
        }
    }
}

namespace Oanda.Rest
{
    public static partial class ClientExtensions
    {
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        public static object CloseOpenTrade(this IClient operations, int accountID, int tradeID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).CloseOpenTradeAsync(accountID, tradeID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> CloseOpenTradeAsync(this IClient operations, int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.CloseOpenTradeWithOperationResponseAsync(accountID, tradeID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        public static object ClosePositionForInstrument(this IClient operations, int accountID, string instrument)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).ClosePositionForInstrumentAsync(accountID, instrument);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> ClosePositionForInstrumentAsync(this IClient operations, int accountID, string instrument, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.ClosePositionForInstrumentWithOperationResponseAsync(accountID, instrument, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='currency'>
        /// Optional.
        /// </param>
        public static CreateAccountOKResponse CreateAccount(this IClient operations, string currency = null)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).CreateAccountAsync(currency);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='currency'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<CreateAccountOKResponse> CreateAccountAsync(this IClient operations, string currency = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<CreateAccountOKResponse> result = await operations.CreateAccountWithOperationResponseAsync(currency, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        public static object CreateOrder(this IClient operations, long accountId)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).CreateOrderAsync(accountId);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> CreateOrderAsync(this IClient operations, long accountId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.CreateOrderWithOperationResponseAsync(accountId, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        public static object DeleteOrder(this IClient operations, long accountId, long orderId)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).DeleteOrderAsync(accountId, orderId);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> DeleteOrderAsync(this IClient operations, long accountId, long orderId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.DeleteOrderWithOperationResponseAsync(accountId, orderId, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        public static GetAccountOKResponse GetAccount(this IClient operations, long accountId)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetAccountAsync(accountId);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<GetAccountOKResponse> GetAccountAsync(this IClient operations, long accountId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<GetAccountOKResponse> result = await operations.GetAccountWithOperationResponseAsync(accountId, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='username'>
        /// Optional.
        /// </param>
        public static GetAccountsOKResponse GetAccounts(this IClient operations, string username = null)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetAccountsAsync(username);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='username'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<GetAccountsOKResponse> GetAccountsAsync(this IClient operations, string username = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<GetAccountsOKResponse> result = await operations.GetAccountsWithOperationResponseAsync(username, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        public static object GetCalendar(this IClient operations)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetCalendarAsync();
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetCalendarAsync(this IClient operations, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetCalendarWithOperationResponseAsync(cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='granularity'>
        /// Optional.
        /// </param>
        /// <param name='count'>
        /// Optional.
        /// </param>
        /// <param name='start'>
        /// Optional.
        /// </param>
        /// <param name='candleFormat'>
        /// Optional.
        /// </param>
        /// <param name='includeFirst'>
        /// Optional.
        /// </param>
        /// <param name='dailyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='alignmentTimezone'>
        /// Optional.
        /// </param>
        /// <param name='weeklyAlignment'>
        /// Optional.
        /// </param>
        public static GetCandlesOKResponse GetCandles(this IClient operations, string instrument, string granularity = null, string count = null, string start = null, string candleFormat = null, string includeFirst = null, string dailyAlignment = null, string alignmentTimezone = null, string weeklyAlignment = null)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetCandlesAsync(instrument, granularity, count, start, candleFormat, includeFirst, dailyAlignment, alignmentTimezone, weeklyAlignment);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='granularity'>
        /// Optional.
        /// </param>
        /// <param name='count'>
        /// Optional.
        /// </param>
        /// <param name='start'>
        /// Optional.
        /// </param>
        /// <param name='candleFormat'>
        /// Optional.
        /// </param>
        /// <param name='includeFirst'>
        /// Optional.
        /// </param>
        /// <param name='dailyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='alignmentTimezone'>
        /// Optional.
        /// </param>
        /// <param name='weeklyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<GetCandlesOKResponse> GetCandlesAsync(this IClient operations, string instrument, string granularity = null, string count = null, string start = null, string candleFormat = null, string includeFirst = null, string dailyAlignment = null, string alignmentTimezone = null, string weeklyAlignment = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<GetCandlesOKResponse> result = await operations.GetCandlesWithOperationResponseAsync(instrument, granularity, count, start, candleFormat, includeFirst, dailyAlignment, alignmentTimezone, weeklyAlignment, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        public static object GetFullTransactionsHistory(this IClient operations, int accountID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetFullTransactionsHistoryAsync(accountID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetFullTransactionsHistoryAsync(this IClient operations, int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetFullTransactionsHistoryWithOperationResponseAsync(accountID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        public static object GetInformationForOrder(this IClient operations, long accountId, long orderId)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetInformationForOrderAsync(accountId, orderId);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetInformationForOrderAsync(this IClient operations, long accountId, long orderId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetInformationForOrderWithOperationResponseAsync(accountId, orderId, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        public static object GetInformationForTrade(this IClient operations, int accountID, int tradeID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetInformationForTradeAsync(accountID, tradeID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetInformationForTradeAsync(this IClient operations, int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetInformationForTradeWithOperationResponseAsync(accountID, tradeID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='transactionID'>
        /// Required.
        /// </param>
        public static object GetInformationForTransaction(this IClient operations, int accountID, string transactionID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetInformationForTransactionAsync(accountID, transactionID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='transactionID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetInformationForTransactionAsync(this IClient operations, int accountID, string transactionID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetInformationForTransactionWithOperationResponseAsync(accountID, transactionID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='fields'>
        /// Optional.
        /// </param>
        /// <param name='instruments'>
        /// Optional.
        /// </param>
        public static GetInstrumentsOKResponse GetInstruments(this IClient operations, string accountId, string fields = null, string instruments = null)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetInstrumentsAsync(accountId, fields, instruments);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='fields'>
        /// Optional.
        /// </param>
        /// <param name='instruments'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<GetInstrumentsOKResponse> GetInstrumentsAsync(this IClient operations, string accountId, string fields = null, string instruments = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<GetInstrumentsOKResponse> result = await operations.GetInstrumentsWithOperationResponseAsync(accountId, fields, instruments, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        public static object GetOpenPositions(this IClient operations, int accountID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetOpenPositionsAsync(accountID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetOpenPositionsAsync(this IClient operations, int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetOpenPositionsWithOperationResponseAsync(accountID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        public static object GetOpenTrades(this IClient operations, int accountID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetOpenTradesAsync(accountID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetOpenTradesAsync(this IClient operations, int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetOpenTradesWithOperationResponseAsync(accountID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        public static object GetPositionForInstrument(this IClient operations, int accountID, string instrument)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetPositionForInstrumentAsync(accountID, instrument);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetPositionForInstrumentAsync(this IClient operations, int accountID, string instrument, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetPositionForInstrumentWithOperationResponseAsync(accountID, instrument, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='instruments'>
        /// Required.
        /// </param>
        /// <param name='since'>
        /// Optional.
        /// </param>
        public static GetPricesOKResponse GetPrices(this IClient operations, string instruments, string since = null)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetPricesAsync(instruments, since);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='instruments'>
        /// Required.
        /// </param>
        /// <param name='since'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<GetPricesOKResponse> GetPricesAsync(this IClient operations, string instruments, string since = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<GetPricesOKResponse> result = await operations.GetPricesWithOperationResponseAsync(instruments, since, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        public static object GetTransactionHistory(this IClient operations, int accountID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).GetTransactionHistoryAsync(accountID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> GetTransactionHistoryAsync(this IClient operations, int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.GetTransactionHistoryWithOperationResponseAsync(accountID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        public static object ModifyTrade(this IClient operations, int accountID, int tradeID)
        {
            return Task.Factory.StartNew((object s) => 
            {
                return ((IClient)s).ModifyTradeAsync(accountID, tradeID);
            }
            , operations, CancellationToken.None, TaskCreationOptions.None, TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
        }
        
        /// <param name='operations'>
        /// Reference to the Oanda.Rest.IClient.
        /// </param>
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public static async Task<object> ModifyTradeAsync(this IClient operations, int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            HttpOperationResponse<object> result = await operations.ModifyTradeWithOperationResponseAsync(accountID, tradeID, cancellationToken).ConfigureAwait(false);
            return result.Body;
        }
    }
    
    public partial interface IClient : IDisposable
    {
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        Uri BaseUri
        {
            get; set; 
        }
        
        /// <summary>
        /// Credentials for authenticating with the service.
        /// </summary>
        ServiceClientCredentials Credentials
        {
            get; set; 
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> CloseOpenTradeWithOperationResponseAsync(int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ClosePositionForInstrumentWithOperationResponseAsync(int accountID, string instrument, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='currency'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<CreateAccountOKResponse>> CreateAccountWithOperationResponseAsync(string currency = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> CreateOrderWithOperationResponseAsync(long accountId, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> DeleteOrderWithOperationResponseAsync(long accountId, long orderId, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetAccountOKResponse>> GetAccountWithOperationResponseAsync(long accountId, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='username'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetAccountsOKResponse>> GetAccountsWithOperationResponseAsync(string username = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetCalendarWithOperationResponseAsync(CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='granularity'>
        /// Optional.
        /// </param>
        /// <param name='count'>
        /// Optional.
        /// </param>
        /// <param name='start'>
        /// Optional.
        /// </param>
        /// <param name='candleFormat'>
        /// Optional.
        /// </param>
        /// <param name='includeFirst'>
        /// Optional.
        /// </param>
        /// <param name='dailyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='alignmentTimezone'>
        /// Optional.
        /// </param>
        /// <param name='weeklyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetCandlesOKResponse>> GetCandlesWithOperationResponseAsync(string instrument, string granularity = null, string count = null, string start = null, string candleFormat = null, string includeFirst = null, string dailyAlignment = null, string alignmentTimezone = null, string weeklyAlignment = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetFullTransactionsHistoryWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetInformationForOrderWithOperationResponseAsync(long accountId, long orderId, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetInformationForTradeWithOperationResponseAsync(int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='transactionID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetInformationForTransactionWithOperationResponseAsync(int accountID, string transactionID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='fields'>
        /// Optional.
        /// </param>
        /// <param name='instruments'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetInstrumentsOKResponse>> GetInstrumentsWithOperationResponseAsync(string accountId, string fields = null, string instruments = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetOpenPositionsWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetOpenTradesWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetPositionForInstrumentWithOperationResponseAsync(int accountID, string instrument, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='instruments'>
        /// Required.
        /// </param>
        /// <param name='since'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<GetPricesOKResponse>> GetPricesWithOperationResponseAsync(string instruments, string since = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> GetTransactionHistoryWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        Task<HttpOperationResponse<object>> ModifyTradeWithOperationResponseAsync(int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken));
    }
    
    public partial class Client : ServiceClient<Client>, IClient
    {
        private Uri _baseUri;
        
        /// <summary>
        /// The base URI of the service.
        /// </summary>
        public Uri BaseUri
        {
            get { return this._baseUri; }
            set { this._baseUri = value; }
        }
        
        private ServiceClientCredentials _credentials;
        
        /// <summary>
        /// Credentials for authenticating with the service.
        /// </summary>
        public ServiceClientCredentials Credentials
        {
            get { return this._credentials; }
            set { this._credentials = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the Client class.
        /// </summary>
        public Client()
            : base()
        {
            this._baseUri = new Uri("http://localhost");
        }
        
        /// <summary>
        /// Initializes a new instance of the Client class.
        /// </summary>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public Client(params DelegatingHandler[] handlers)
            : base(handlers)
        {
            this._baseUri = new Uri("http://localhost");
        }
        
        /// <summary>
        /// Initializes a new instance of the Client class.
        /// </summary>
        /// <param name='rootHandler'>
        /// Optional. The http client handler used to handle http transport.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public Client(HttpClientHandler rootHandler, params DelegatingHandler[] handlers)
            : base(rootHandler, handlers)
        {
            this._baseUri = new Uri("http://localhost");
        }
        
        /// <summary>
        /// Initializes a new instance of the Client class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public Client(Uri baseUri, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this._baseUri = baseUri;
        }
        
        /// <summary>
        /// Initializes a new instance of the Client class.
        /// </summary>
        /// <param name='credentials'>
        /// Required. Credentials for authenticating with the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public Client(ServiceClientCredentials credentials, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this._credentials = credentials;
            
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }
        
        /// <summary>
        /// Initializes a new instance of the Client class.
        /// </summary>
        /// <param name='baseUri'>
        /// Optional. The base URI of the service.
        /// </param>
        /// <param name='credentials'>
        /// Required. Credentials for authenticating with the service.
        /// </param>
        /// <param name='handlers'>
        /// Optional. The set of delegating handlers to insert in the http
        /// client pipeline.
        /// </param>
        public Client(Uri baseUri, ServiceClientCredentials credentials, params DelegatingHandler[] handlers)
            : this(handlers)
        {
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this._baseUri = baseUri;
            this._credentials = credentials;
            
            if (this.Credentials != null)
            {
                this.Credentials.InitializeServiceClient(this);
            }
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> CloseOpenTradeWithOperationResponseAsync(int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                tracingParameters.Add("tradeID", tradeID);
                ServiceClientTracing.Enter(invocationId, this, "CloseOpenTradeAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/trades/";
            url = url + Uri.EscapeDataString(tradeID.ToString());
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Delete;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> ClosePositionForInstrumentWithOperationResponseAsync(int accountID, string instrument, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Validate
            if (instrument == null)
            {
                throw new ArgumentNullException("instrument");
            }
            
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                tracingParameters.Add("instrument", instrument);
                ServiceClientTracing.Enter(invocationId, this, "ClosePositionForInstrumentAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/positions/";
            url = url + Uri.EscapeDataString(instrument);
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Delete;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='currency'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<CreateAccountOKResponse>> CreateAccountWithOperationResponseAsync(string currency = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("currency", currency);
                ServiceClientTracing.Enter(invocationId, this, "CreateAccountAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts";
            List<string> queryParameters = new List<string>();
            if (currency != null)
            {
                queryParameters.Add("currency=" + Uri.EscapeDataString(currency));
            }
            if (queryParameters.Count > 0)
            {
                url = url + "?" + string.Join("&", queryParameters);
            }
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                ErrorModel errorModel = new ErrorModel();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    errorModel.DeserializeJson(responseDoc);
                }
                HttpOperationException<ErrorModel> ex = new HttpOperationException<ErrorModel>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = errorModel;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<CreateAccountOKResponse> result = new HttpOperationResponse<CreateAccountOKResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                CreateAccountOKResponse resultModel = new CreateAccountOKResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> CreateOrderWithOperationResponseAsync(long accountId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountId", accountId);
                ServiceClientTracing.Enter(invocationId, this, "CreateOrderAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountId.ToString());
            url = url + "/orders";
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Post;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> DeleteOrderWithOperationResponseAsync(long accountId, long orderId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountId", accountId);
                tracingParameters.Add("orderId", orderId);
                ServiceClientTracing.Enter(invocationId, this, "DeleteOrderAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountId.ToString());
            url = url + "/orders/";
            url = url + Uri.EscapeDataString(orderId.ToString());
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Delete;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<GetAccountOKResponse>> GetAccountWithOperationResponseAsync(long accountId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountId", accountId);
                ServiceClientTracing.Enter(invocationId, this, "GetAccountAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountId.ToString());
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<GetAccountOKResponse> result = new HttpOperationResponse<GetAccountOKResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                GetAccountOKResponse resultModel = new GetAccountOKResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='username'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<GetAccountsOKResponse>> GetAccountsWithOperationResponseAsync(string username = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("username", username);
                ServiceClientTracing.Enter(invocationId, this, "GetAccountsAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts";
            List<string> queryParameters = new List<string>();
            if (username != null)
            {
                queryParameters.Add("username=" + Uri.EscapeDataString(username));
            }
            if (queryParameters.Count > 0)
            {
                url = url + "?" + string.Join("&", queryParameters);
            }
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                ErrorModel errorModel = new ErrorModel();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    errorModel.DeserializeJson(responseDoc);
                }
                HttpOperationException<ErrorModel> ex = new HttpOperationException<ErrorModel>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = errorModel;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<GetAccountsOKResponse> result = new HttpOperationResponse<GetAccountsOKResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                GetAccountsOKResponse resultModel = new GetAccountsOKResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetCalendarWithOperationResponseAsync(CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                ServiceClientTracing.Enter(invocationId, this, "GetCalendarAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/labs/v1/calendar";
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='granularity'>
        /// Optional.
        /// </param>
        /// <param name='count'>
        /// Optional.
        /// </param>
        /// <param name='start'>
        /// Optional.
        /// </param>
        /// <param name='candleFormat'>
        /// Optional.
        /// </param>
        /// <param name='includeFirst'>
        /// Optional.
        /// </param>
        /// <param name='dailyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='alignmentTimezone'>
        /// Optional.
        /// </param>
        /// <param name='weeklyAlignment'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<GetCandlesOKResponse>> GetCandlesWithOperationResponseAsync(string instrument, string granularity = null, string count = null, string start = null, string candleFormat = null, string includeFirst = null, string dailyAlignment = null, string alignmentTimezone = null, string weeklyAlignment = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Validate
            if (instrument == null)
            {
                throw new ArgumentNullException("instrument");
            }
            
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("instrument", instrument);
                tracingParameters.Add("granularity", granularity);
                tracingParameters.Add("count", count);
                tracingParameters.Add("start", start);
                tracingParameters.Add("candleFormat", candleFormat);
                tracingParameters.Add("includeFirst", includeFirst);
                tracingParameters.Add("dailyAlignment", dailyAlignment);
                tracingParameters.Add("alignmentTimezone", alignmentTimezone);
                tracingParameters.Add("weeklyAlignment", weeklyAlignment);
                ServiceClientTracing.Enter(invocationId, this, "GetCandlesAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/candles";
            List<string> queryParameters = new List<string>();
            queryParameters.Add("instrument=" + Uri.EscapeDataString(instrument));
            if (granularity != null)
            {
                queryParameters.Add("granularity=" + Uri.EscapeDataString(granularity));
            }
            if (count != null)
            {
                queryParameters.Add("count=" + Uri.EscapeDataString(count));
            }
            if (start != null)
            {
                queryParameters.Add("start=" + Uri.EscapeDataString(start));
            }
            if (candleFormat != null)
            {
                queryParameters.Add("candleFormat=" + Uri.EscapeDataString(candleFormat));
            }
            if (includeFirst != null)
            {
                queryParameters.Add("includeFirst=" + Uri.EscapeDataString(includeFirst));
            }
            if (dailyAlignment != null)
            {
                queryParameters.Add("dailyAlignment=" + Uri.EscapeDataString(dailyAlignment));
            }
            if (alignmentTimezone != null)
            {
                queryParameters.Add("alignmentTimezone=" + Uri.EscapeDataString(alignmentTimezone));
            }
            if (weeklyAlignment != null)
            {
                queryParameters.Add("weeklyAlignment=" + Uri.EscapeDataString(weeklyAlignment));
            }
            if (queryParameters.Count > 0)
            {
                url = url + "?" + string.Join("&", queryParameters);
            }
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<GetCandlesOKResponse> result = new HttpOperationResponse<GetCandlesOKResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                GetCandlesOKResponse resultModel = new GetCandlesOKResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetFullTransactionsHistoryWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                ServiceClientTracing.Enter(invocationId, this, "GetFullTransactionsHistoryAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/alltransactions";
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='orderId'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetInformationForOrderWithOperationResponseAsync(long accountId, long orderId, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountId", accountId);
                tracingParameters.Add("orderId", orderId);
                ServiceClientTracing.Enter(invocationId, this, "GetInformationForOrderAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountId.ToString());
            url = url + "/orders/";
            url = url + Uri.EscapeDataString(orderId.ToString());
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetInformationForTradeWithOperationResponseAsync(int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                tracingParameters.Add("tradeID", tradeID);
                ServiceClientTracing.Enter(invocationId, this, "GetInformationForTradeAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/trades/";
            url = url + Uri.EscapeDataString(tradeID.ToString());
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='transactionID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetInformationForTransactionWithOperationResponseAsync(int accountID, string transactionID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Validate
            if (transactionID == null)
            {
                throw new ArgumentNullException("transactionID");
            }
            
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                tracingParameters.Add("transactionID", transactionID);
                ServiceClientTracing.Enter(invocationId, this, "GetInformationForTransactionAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/transactions/";
            url = url + Uri.EscapeDataString(transactionID);
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountId'>
        /// Required.
        /// </param>
        /// <param name='fields'>
        /// Optional.
        /// </param>
        /// <param name='instruments'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<GetInstrumentsOKResponse>> GetInstrumentsWithOperationResponseAsync(string accountId, string fields = null, string instruments = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Validate
            if (accountId == null)
            {
                throw new ArgumentNullException("accountId");
            }
            
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountId", accountId);
                tracingParameters.Add("fields", fields);
                tracingParameters.Add("instruments", instruments);
                ServiceClientTracing.Enter(invocationId, this, "GetInstrumentsAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/instruments";
            List<string> queryParameters = new List<string>();
            queryParameters.Add("accountId=" + Uri.EscapeDataString(accountId));
            if (fields != null)
            {
                queryParameters.Add("fields=" + Uri.EscapeDataString(fields));
            }
            if (instruments != null)
            {
                queryParameters.Add("instruments=" + Uri.EscapeDataString(instruments));
            }
            if (queryParameters.Count > 0)
            {
                url = url + "?" + string.Join("&", queryParameters);
            }
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                ErrorModel errorModel = new ErrorModel();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    errorModel.DeserializeJson(responseDoc);
                }
                HttpOperationException<ErrorModel> ex = new HttpOperationException<ErrorModel>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = errorModel;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<GetInstrumentsOKResponse> result = new HttpOperationResponse<GetInstrumentsOKResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                GetInstrumentsOKResponse resultModel = new GetInstrumentsOKResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetOpenPositionsWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                ServiceClientTracing.Enter(invocationId, this, "GetOpenPositionsAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/positions";
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetOpenTradesWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                ServiceClientTracing.Enter(invocationId, this, "GetOpenTradesAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/trades";
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='instrument'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetPositionForInstrumentWithOperationResponseAsync(int accountID, string instrument, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Validate
            if (instrument == null)
            {
                throw new ArgumentNullException("instrument");
            }
            
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                tracingParameters.Add("instrument", instrument);
                ServiceClientTracing.Enter(invocationId, this, "GetPositionForInstrumentAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/positions/";
            url = url + Uri.EscapeDataString(instrument);
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='instruments'>
        /// Required.
        /// </param>
        /// <param name='since'>
        /// Optional.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<GetPricesOKResponse>> GetPricesWithOperationResponseAsync(string instruments, string since = null, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Validate
            if (instruments == null)
            {
                throw new ArgumentNullException("instruments");
            }
            
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("instruments", instruments);
                tracingParameters.Add("since", since);
                ServiceClientTracing.Enter(invocationId, this, "GetPricesAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/prices";
            List<string> queryParameters = new List<string>();
            queryParameters.Add("instruments=" + Uri.EscapeDataString(instruments));
            if (since != null)
            {
                queryParameters.Add("since=" + Uri.EscapeDataString(since));
            }
            if (queryParameters.Count > 0)
            {
                url = url + "?" + string.Join("&", queryParameters);
            }
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<GetPricesOKResponse> result = new HttpOperationResponse<GetPricesOKResponse>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            if (statusCode == HttpStatusCode.OK)
            {
                GetPricesOKResponse resultModel = new GetPricesOKResponse();
                JToken responseDoc = null;
                if (string.IsNullOrEmpty(responseContent) == false)
                {
                    responseDoc = JToken.Parse(responseContent);
                }
                if (responseDoc != null)
                {
                    resultModel.DeserializeJson(responseDoc);
                }
                result.Body = resultModel;
            }
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> GetTransactionHistoryWithOperationResponseAsync(int accountID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                ServiceClientTracing.Enter(invocationId, this, "GetTransactionHistoryAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/transactions";
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = HttpMethod.Get;
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
        
        /// <param name='accountID'>
        /// Required.
        /// </param>
        /// <param name='tradeID'>
        /// Required.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        public async Task<HttpOperationResponse<object>> ModifyTradeWithOperationResponseAsync(int accountID, int tradeID, CancellationToken cancellationToken = default(System.Threading.CancellationToken))
        {
            // Tracing
            bool shouldTrace = ServiceClientTracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = ServiceClientTracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("accountID", accountID);
                tracingParameters.Add("tradeID", tradeID);
                ServiceClientTracing.Enter(invocationId, this, "ModifyTradeAsync", tracingParameters);
            }
            
            // Construct URL
            string url = "";
            url = url + "/v1/accounts/";
            url = url + Uri.EscapeDataString(accountID.ToString());
            url = url + "/trades/";
            url = url + Uri.EscapeDataString(tradeID.ToString());
            string baseUrl = this.BaseUri.AbsoluteUri;
            // Trim '/' character from the end of baseUrl and beginning of url.
            if (baseUrl[baseUrl.Length - 1] == '/')
            {
                baseUrl = baseUrl.Substring(0, baseUrl.Length - 1);
            }
            if (url[0] == '/')
            {
                url = url.Substring(1);
            }
            url = baseUrl + "/" + url;
            url = url.Replace(" ", "%20");
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = new HttpRequestMessage();
            httpRequest.Method = new HttpMethod("PATCH");
            httpRequest.RequestUri = new Uri(url);
            
            // Set Credentials
            if (this.Credentials != null)
            {
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            }
            
            // Send Request
            if (shouldTrace)
            {
                ServiceClientTracing.SendRequest(invocationId, httpRequest);
            }
            cancellationToken.ThrowIfCancellationRequested();
            HttpResponseMessage httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
            if (shouldTrace)
            {
                ServiceClientTracing.ReceiveResponse(invocationId, httpResponse);
            }
            HttpStatusCode statusCode = httpResponse.StatusCode;
            cancellationToken.ThrowIfCancellationRequested();
            string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
            if (statusCode != HttpStatusCode.OK)
            {
                HttpOperationException<object> ex = new HttpOperationException<object>();
                ex.Request = httpRequest;
                ex.Response = httpResponse;
                ex.Body = null;
                if (shouldTrace)
                {
                    ServiceClientTracing.Error(invocationId, ex);
                }
                throw ex;
            }
            
            // Create Result
            HttpOperationResponse<object> result = new HttpOperationResponse<object>();
            result.Request = httpRequest;
            result.Response = httpResponse;
            
            // Deserialize Response
            object resultModel = default(object);
            result.Body = resultModel;
            
            if (shouldTrace)
            {
                ServiceClientTracing.Exit(invocationId, result);
            }
            return result;
        }
    }
}
